{
    "contents" : "library(diversitree)\nlibrary(phytools)\n\n########################### going from diversitree format to phytools format: ####################################\n##################################################################################################################\ndivtophymap<-function(phy,y){\n tool<-phy\n tool$orig<-NULL\n tool$node.label<-NULL\n tool$maps<-vector(\"list\",dim(phy$edge)[1])\n for(i in 1:(dim(phy$edge)[1])) tool$maps[[i]]<-onemapbranch(phy,y,i)\n return(tool)\n}\n\nonemapbranch<-function(phy,y,i){\n hist<-y$history[[i]]\n hist2<-rbind(hist,c(phy$edge.length[i],hist[dim(hist)[1],2]))\n returnme<-diff(hist2[,1])\n names(returnme)<-hist[,2]\n return(returnme)\n}\n\nnodestatesmake<-function(tool){\n node.states<-tool$edge\n for(i in 1:(dim(tool$edge)[1])) node.states[i,]<-c(as.integer(names(tool$maps[[i]])[1]),as.integer(names(tool$maps[[i]])[length(tool$maps[[i]])]))\n tool$node.states<-node.states\n return(tool)\n}\n\nstatesmake<-function(tool){\nstates<-rep(0,length(tool$tip.label))\nfor(i in 1:length(tool$tip.label)) states[i]<-tool$node.states[,2][tool$edge[,2]==i]\ntool$states<-states\nreturn(tool)\n}\n\nmakemappededge<-function(tree,pid){\n numberofstates<-length(pid)\n returnme<-matrix(rep(0,numberofstates*length(tree$maps)),nrow=length(tree$maps))\n for(i in 1:length(tree$maps)){\n  for(j in 1:numberofstates){\n   returnme[i,j]<-sum(tree$maps[[i]][names(tree$maps[[i]])==j])\n  }\n }\n return(returnme)\n}\n\ndivtophy<-function(phy,y){\n tool<-divtophymap(phy,y)\n tool<-nodestatesmake(tool)\n tool<-statesmake(tool)\n tool$mapped.edge<-makemappededge(tool,y$states)\n return(tool)\n}\n##################################################################################################\n##################################################################################################\n\n\n######### create a 7 tip tree with a state space of size 2:\n\n\nstatesize=2\ntipcount=7\n\n set.seed(892)\n i<-statesize\n numtips<-tipcount\n phy<-NULL\n while(is.null(phy)) phy<-tree.bd(c(.1, .03), max.taxa=numtips)\n Q<-matrix(10*abs(rnorm(i^2)),nrow=i) \n diag(Q)<-0\n diag(Q)<-apply(-Q,1,sum)\n\n dimQ<-dim(Q)[1]\n q<-as.vector(t(Q))[-seq(from=1,to=(dimQ^2),by=(dimQ+1))]\n pid<-rep(1/dimQ,dimQ)\n\n x<-NULL\n while(length(unique(x))<=1) x = sim.character(phy, pars=Q, x0=1, model=\"mkn\", br=NULL)\n lik <- make.mkn(phy, x[1:numtips], dimQ,strict=FALSE)\n y = asr.stoch(lik, q)\n z<-divtophy(phy,y)\n\nz.reordered = reorder(z, order = \"pr\")\n\nsimSize = 10000\nresultMat = matrix(0,simSize,4)\n\nfor(i in 1:simSize){\n  resultMat[i,] = twoStateSufficientStatistics(z.reordered$edge, z.reordered$states-1, z.reordered$edge.length, Q[1,2], Q[2,1], c(0.5,0.5))\n}\n\nsummary(resultMat)\n\n###############################################################################\n########################### summary statistics ################################\n###############################################################################\n\n# 10,000 samples of the state history of the tree z yielded the following statistics\n\n## number of transitions from state 1 to state 2\n## Min. 1st Qu.  Median    Mean  3rd Qu.    Max. \n## 7.00   84.00   89.00   88.65    94.00  118.00 \n\n## number of transitions from state 2 to state 1\n## Min. 1st Qu.  Median    Mean  3rd Qu.    Max. \n## 6.00   83.00   88.00   87.83    93.00  117.00 \n\n## amount of time spent in state 1\n##  Min.  1st Qu.  Median    Mean  3rd Qu.    Max. \n## 15.21    17.82   18.25   18.25    18.69   20.69 \n\n## amount of time spent in state2\n##   Min. 1st Qu.  Median    Mean  3rd Qu.    Max. \n##  3.277   5.279   5.713   5.721    6.150   8.753 \n\n",
    "created" : 1382388099046.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2511338817",
    "id" : "3752532E",
    "lastKnownWriteTime" : 1382392694,
    "path" : "~/Documents/Manuscripts/papers/ind_origin/code/Jan/twostatetree/setup.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}