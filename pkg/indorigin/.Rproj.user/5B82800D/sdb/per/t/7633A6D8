{
    "contents" : "two.state.trans.prob = function(forward.rate, backward.rate, elapsed.time){\n  total.rate = forward.rate + backward.rate               \n  \n  return((matrix(c(rep(backward.rate,2),rep(forward.rate,2)),2,2) +\n            matrix(c(forward.rate, -backward.rate, -forward.rate, backward.rate),2,2)*\n            exp(-total.rate*elapsed.time))/total.rate)    \n}\n\n\ninRTwoStatePartLikehoods = function(my.tree, my.data, forward.rate, backward.rate){\n  \n  ## reorder the edges in the \"pruningwise\" order\n  my.tree = reorder(my.tree, order = \"pr\")\n  \n  if (!(\"phylo\" %in% class(my.tree)))\n    stop(\"Error: object \\\"my.tree\\\" is not of class \\\"phylo\\\"\")\n  \n  if (is.null(my.tree$edge.length))\n    stop(\"Error: tree \\\" my.tree\\\" must have branch lengths.\")\n  \n  ## reorder data on tips to match the order of the my.tree phylo object\n  if (!is.null(names(my.data))) {\n    if(!any(is.na(match(names(my.data), my.tree$tip.label)))){\n      my.data = my.data[my.tree$tip.label]\n    }else{\n      warning('the names of argument \"my.data\" and the names of the tip labels\ndid not match: the former were ignored in the analysis.')\n    }\n  }\n  \n  ## prepare transition probability matrices (this of course can and should be done in C++ as well)\n  ## prob.array = array(0, dim=c(2,2,length(my.tree$edge.length)))            \n  \n  ## for (i in 1:length(my.tree$edge.length)){\n  ##  prob.array[,,i] = two.state.trans.prob(forward.rate, backward.rate, my.tree$edge.length[i])          \n  ## }            \n  \n  return(twoStateSufficientStatistics(my.tree$edge, my.data, my.tree$edge.length, forward.rate, backward.rate))\n}\n",
    "created" : 1381877655162.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "262474557",
    "id" : "7633A6D8",
    "lastKnownWriteTime" : 1381955104,
    "path" : "~/Documents/code/indorigin/R/test_likelihood.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}